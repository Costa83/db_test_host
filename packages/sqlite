#define _GNU_SOURCE
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#include <sqlite3.h>

#include "sttData.h"
#include "db_fonctions.h"

#define NB_TABLE_ANNEXES 3
#define NB_KEY 12
#define NB_UNITS 9
#define TIME_STRING_LENGTH 20


#ifdef DEBUG
#define dbg(message) do { \
	 printf(message"\n");\
} while(0)
#warning DEBUG mode
#else
#define dbg(...)
#warning RELEASE mode
#endif

int _db_init(void *cbarg);

int callback(void *NotUsed, int argc, char **argv, char **azColName) {


	 dbg("Dossier : src/database - Fichier sqlite_fonctions.c  callback");

	 int i;
   for(i = 0; i<argc; i++) {
      printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
   }
   printf("\n");
   return 0;
}

/**Return -1 if there is a problem, 0 if succeeded**/
int db_connect(void

**arg, const char *dbpath)
{
	dbg("Dossier : src/database - Fichier sqlite_fonctions.c  db_connect");

	sqlite3 **argdb = (sqlite3 **)arg;
	/**Variables SQLite**/
	int rc;

	/** Open database **/
	int flags = SQLITE_OPEN_READWRITE;
	rc = sqlite3_open_v2(dbpath, argdb, flags, NULL);
	sqlite3 *db = *argdb;
	if(rc != 0) {
		int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
		rc = sqlite3_open_v2(dbpath, argdb, flags, NULL);
		if(rc != 0) {
			if (db != NULL)
				fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
			return -1;
		}
		db = *argdb;
		_db_init(db);
	}

	fprintf(stdout,"sql_connect: Opened database successfully\n");
	return rc;
}

int _db_init(void *cbarg)
{


	dbg("Dossier : src/database - Fichier sqlite_fonctions.c  db_init");

	sqlite3 *db = (sqlite3 *)cbarg;

	int rc;
	sqlite3_stmt *stmt;
	char *query = NULL;
	const char *Name_Table[NB_TABLE_ANNEXES];
	const char *key[NB_KEY];
	const char *Names_Units[NB_UNITS];
	/**Create Tables Units, Source and Type**/
	Name_Table[0]="Units";
	Name_Table[1]="Source";
	Name_Table[2]="Key";

	for(int i=0; i<NB_TABLE_ANNEXES; i++)
	{
		if(asprintf(&query, "CREATE TABLE IF NOT EXISTS Table_%s(Id_%s INTEGER,%s TEXT, UNIQUE(Id_%s, %s) );", Name_Table[i], Name_Table[i], Name_Table[i], Name_Table[i], Name_Table[i]) < 0)
			printf("error\n");

		sqlite3_prepare_v2(db, query, strlen(query), &stmt, NULL);
		rc = sqlite3_step(stmt);
		if (rc != SQLITE_DONE)
		{
			printf("ERROR inserting data Table_%s: %s\n",Name_Table[i], sqlite3_errmsg(db));
			sqlite3_finalize(stmt);
			free(query);
			return -1;
		}
		sqlite3_finalize(stmt);
		free(query);
	}
	/**Create Table STT**/
	sqlite3_prepare_v2(db, "CREATE TABLE IF NOT EXISTS STT(Date INTEGER,Value REAL, Id_Source INTEGER, Id_Units INTEGER, Id_Key INTEGER );", -1, &stmt, NULL);
	rc = sqlite3_step(stmt);
	if (rc != SQLITE_DONE)
	{
		printf("ERROR inserting data table STT: %s\n", sqlite3_errmsg(db));
		sqlite3_finalize(stmt);
		return -1;
	}
	sqlite3_finalize(stmt);

	/**Fill the three tables UNITS, KEY and TYPE**/
	/**table SOURCE**/
	for(int j=0; j<3;j++)
	{
		if(asprintf(&query, "insert into Table_%s (Id_%s, %s) values ('%d', 'FAKE%d');",Name_Table[1] , Name_Table[1] , Name_Table[1] , j, j) < 0)
			printf("error\n");
		sqlite3_prepare_v2(db, query, strlen(query), &stmt, NULL);
		rc = sqlite3_step(stmt);
		if (rc != SQLITE_DONE)
		{
			printf("ERROR inserting data Table_%s: %s\n",Name_Table[1], sqlite3_errmsg(db));
			sqlite3_finalize(stmt);
			free(query);
			return -1;
		}
		sqlite3_finalize(stmt);
		free(query);
	}
	/**table Units**/
	Names_Units[0]="W";
	Names_Units[1]="km/h";
	Names_Units[2]="%";
	Names_Units[3]="km";
	Names_Units[4]="V";
	Names_Units[5]="bpm";
	Names_Units[6]="RPM";
	Names_Units[7]="°C";
	Names_Units[8]="Pa";

	for(int j=0; j<NB_UNITS;j++)
	{
		if(asprintf(&query, "insert into Table_%s (Id_%s, %s) values ('%d', '%s');",Name_Table[0] , Name_Table[0] , Name_Table[0] , j, Names_Units[j]) < 0)
			printf("error\n");
		sqlite3_prepare_v2(db, query, strlen(query), &stmt, NULL);
		rc = sqlite3_step(stmt);
		if (rc != SQLITE_DONE)
		{
			printf("ERROR inserting data Table_%s: %s\n",Name_Table[0], sqlite3_errmsg(db));
			sqlite3_finalize(stmt);
			free(query);
			return -1;
		}
		sqlite3_finalize(stmt);
		free(query);
	}

	/**table Key**/
	key[0]="motorPower";
	key[1]="speed";
	key[2]="battery";
	key[3]="solarPower";
	key[4]="instantSpeed";
	key[5]="distance";
	key[6]="tense";
	key[7]="heartFrequency";
	key[8]="pedallingFrequency";
	key[9]="temperature";
	key[10]="humidity";
	key[11]="pressure";
	for(int j=0; j<NB_KEY;j++)
	{
		if(asprintf(&query, "insert into Table_%s (Id_%s, %s) values ('%d', '%s');",Name_Table[2] , Name_Table[2] , Name_Table[2] , j, key[j]) < 0)
			printf("error\n");
		sqlite3_prepare_v2(db, query, strlen(query), &stmt, NULL);
		rc = sqlite3_step(stmt);
		if (rc != SQLITE_DONE)
		{
			printf("ERROR inserting data Table_%s: %s\n",Name_Table[2], sqlite3_errmsg(db));
			sqlite3_finalize(stmt);
			free(query);
			return -1;
		}
		sqlite3_finalize(stmt);
		free(query);
	}
	printf("Create tables successfully\n");
	return rc;
}

int db_init(void *cbarg)
{
	int rc = 0;
	return rc;
}


void db_disconnect(void *cbarg) {

	dbg("Dossier : src/database - Fichier sqlite_fonctions.c  db_disconnect");

	sqlite3 *db = (sqlite3 *)cbarg;
	sqlite3_close(db);
}
/*###############################################################################################*/
/*#######################/*###############################################################################################*/
/*########################################################################*/

//Guillaume Ajout 14_02_20
static int db_find(sqlite3 *db, const char *path)
{
	sqlite3_stmt *statement;
#ifndef MEDIA_SQLITE_EXT
	char *sql = "select \"Id_Source\" from \"Table_Source\" where \"Id_Source\"==^";
#else
	char *sql = "select \"opusid\" from \"media\" where \"url\"=@PATH";
#endif
	int ret = sqlite3_prepare_v2(db, sql, -1, &statement, NULL);
	SQLITE3_CHECK(ret, -1, sql);

	ret = sqlite3_bind_text(statement, sqlite3_bind_parameter_index(statement, "@PATH"), path, -1, SQLITE_STATIC);
	SQLITE3_CHECK(ret, -1, sql);

	int id = _execute(statement);

#ifdef MEDIA_SQLITE_EXT
	if (id == -1)
	{
		char *sql = "select \"id\" from \"word\" where \"name\"=@NAME";
		sqlite3_prepare_v2(db, sql, -1, &statement, NULL);
		/** set the default value of @FIELDS **/
		sqlite3_bind_text(statement, sqlite3_bind_parameter_index(statement, "@NAME"), path, -1, SQLITE_STATIC);

		int wordid = _execute(statement);
		if (wordid != -1)
		{
			const char *queries[] = {
				"select \"id\" from \"opus\" where \"titleid\"=@ID",
				"select \"id\" from \"opus\" inner join artist on artist.id=opus.artistid  where artist.wordid=@ID",
				"select \"id\" from \"opus\" inner join album on album.id=opus.albumid  where album.wordid=@ID",
				NULL
			};
			int i = 0;
			while (id == -1 && queries[i] != NULL)
			{
				sqlite3_prepare_v2(db, queries[i], -1, &statement, NULL);
				/** set the default value of @FIELDS **/
				sqlite3_bind_int(statement, sqlite3_bind_parameter_index(statement, "@ID"), wordid);
				id = _execute(statement);
				i++;
			}
		}
	}
#endif
	sqlite3_finalize(statement);
	return id;
}

/*###############################################################################################*/
/*#######################/*###############################################################################################*/
/*########################################################################*/

int db_insert(void *cbarg, struct sttdata *data1) {

  dbg("Dossier : src/database - Fichier sqlite_fonctions.c  db_insert()");

	sqlite3 *db = (sqlite3 *)cbarg;
	const char *key[NB_KEY];
	const char *Names_Units[NB_UNITS];
	key[0]="motorPower";
	key[1]="speed";
	key[2]="battery";
	key[3]="solarPower";
	key[4]="instantSpeed";
	key[5]="distance";
	key[6]="tense";
	key[7]="heartFrequency";
	key[8]="pedallingFrequency";
	key[9]="temperature";
	key[10]="humidity";
	key[11]="pressure";

	Names_Units[0]="W";
	Names_Units[1]="km/h";
	Names_Units[2]="%";
	Names_Units[3]="km";
	Names_Units[4]="V";
	Names_Units[5]="bpm";
	Names_Units[6]="RPM";
	Names_Units[7]="°C";
	Names_Units[8]="Pa";

	if (data1 == NULL) {
		return -1;
	}
	int rc;
	/** create sql request**/
	char *query = "insert into \"STT\" (\"Date\" ,\"Value\", \"Id_Source\", \"Id_Units\", \"Id_Key\") values(@mydate, @myvalue, @mysource, @myunit, @mykey);";
	sqlite3_stmt *stmt = NULL;
	char buffer [TIME_STRING_LENGTH];
	rc = sqlite3_prepare_v2(db, query, -1, &stmt, NULL);
	if (rc != SQLITE_OK)
	{
		printf("ERROR preparing data %p : %d\n", db, rc);
		sqlite3_finalize(stmt);
		return -1;
	}
	int index, i, j,k,l;
	for(i = 0; i < 3; i++)
	{

		for(j = 0; j < NB_KEY; j++)
		{
			if (data1->sensors[i].data[j].key != NULL)
			{
				/** Date and Time **/
				index = sqlite3_bind_parameter_index(stmt, "@mydate");
				rc = sqlite3_bind_int(stmt, index, data1->Date);
				if (rc != SQLITE_OK)
				{
					printf("ERROR binding data 1: %d\n", rc);
					sqlite3_finalize(stmt);
					return -1;
				}

				/** Value **/
				index = sqlite3_bind_parameter_index(stmt, "@myvalue");
				rc=sqlite3_bind_double(stmt, index, data1->sensors[i].data[j].value);
				if (rc != SQLITE_OK)
				{
					printf("ERROR binding data 2: %d\n", rc);
					sqlite3_finalize(stmt);
					return -1;
				}

				/** Source Id **/
				index = sqlite3_bind_parameter_index(stmt, "@mysource");

				//For managing more than 3 sources
				//Find strcmp(data1->sensors[i].Source in database

					//Create new request
				//If contains so attribute the index associated
				//else insert a new source new index

				if(strcmp(data1->sensors[i].Source,"FAKE1")==0) rc=sqlite3_bind_int(stmt,index,0);
				else if(strcmp(data1->sensors[i].Source,"FAKE2")==0) rc=sqlite3_bind_int(stmt,index,1);
				else if(strcmp(data1->sensors[i].Source,"FAKE3")==0) rc=sqlite3_bind_int(stmt,index,2);

				if (rc != SQLITE_OK)
				{
					printf("ERROR binding data 3: %d\n", rc);
					sqlite3_finalize(stmt);
					return -1;
				}


				/** Unit Id **/
				index = sqlite3_bind_parameter_index(stmt, "@myunit");
				k=0;
				while(strcmp(data1->sensors[i].data[j].unit, Names_Units[k])!=0)
				{
					 k++;
				 }
				rc=sqlite3_bind_int(stmt,index,k);
				if (rc != SQLITE_OK)
				{
					printf("ERROR binding data 4: %d\n", rc);
					sqlite3_finalize(stmt);
					return -1;
				}
				/** Key Id **/
				index = sqlite3_bind_parameter_index(stmt, "@mykey");
				l=0;
				while(strcmp(data1->sensors[i].data[j].key, key[l])!=0)
				{
					l++;
				}

				rc=sqlite3_bind_int(stmt,index,l);
				if (rc != SQLITE_OK)
				{
					printf("ERROR binding data 5: %d\n", rc);
					sqlite3_finalize(stmt);
					return -1;
				}
				/** Send Data **/
				rc = sqlite3_step(stmt);
				if (rc != SQLITE_DONE)
				{
					printf("ERROR inserting data: %s\n", sqlite3_errmsg(db));
					sqlite3_finalize(stmt);
					return -1;
				}
				sqlite3_reset(stmt);
				sqlite3_clear_bindings(stmt);
			}
		}
	}
	sqlite3_finalize(stmt);
}

/**Print db Sqlite **/
int db_print_db(void *cbarg)
{

	dbg("Dossier : src/database - Fichier sqlite_fonctions.c  db_print_db");

	sqlite3 *db = (sqlite3 *)cbarg;
	sqlite3_stmt *stmt = NULL;
	int rc;
	char * query = NULL;
	char *Name_Table[3];
	Name_Table[0]="Units";
	Name_Table[1]="Source";
	Name_Table[2]="Key";
	if (asprintf(&query, "select STT.Date, STT.Value, Table_%s.%s, Table_%s.%s, Table_%s.%s from STT inner join Table_%s on STT.Id_%s = Table_%s.Id_%s inner join Table_%s on STT.Id_%s = Table_%s.Id_%s"
		" inner join Table_%s on STT.Id_%s = Table_%s.Id_%s",Name_Table[0], Name_Table[0],Name_Table[1], Name_Table[1],Name_Table[2], Name_Table[2], Name_Table[0], Name_Table[0], Name_Table[0],
		Name_Table[0], Name_Table[1], Name_Table[1], Name_Table[1], Name_Table[1], Name_Table[2], Name_Table[2], Name_Table[2], Name_Table[2]) < 0)
		printf("error\n");
	//printf("print = %s\n",query);
	rc = sqlite3_prepare_v2(db, query, -1, &stmt, NULL);
	if (rc != SQLITE_OK)
	{
		printf("ERROR preparing data %p : %d\n", db, rc);
		sqlite3_finalize(stmt);
		return -1;
	}
	while((rc = sqlite3_step(stmt))==SQLITE_ROW)
	{
		time_t mtime = sqlite3_column_int(stmt, 0);
		char buffer[64];
		strftime(buffer, sizeof(buffer), "%d/%m/%Y %T", localtime(&mtime));
		printf("%s Source  %s %s %f %s \n", buffer, sqlite3_column_text(stmt, 3), sqlite3_column_text(stmt, 4), sqlite3_column_double(stmt, 1), sqlite3_column_text(stmt, 2));
	}
	sqlite3_finalize(stmt);
	free(query);
	return rc;
}
